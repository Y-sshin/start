#day09
기본문법
함수 만들기
객체지향
	클래스	인터페이스	추상클래스
	유용한 클래스들
	컬렉션
		리스트 셋 맵
	입출력	네트워크	쓰레드
----
jdbc-jsp
awt.swing-GUI

함수(메서드,Function)
	한 가지 작업을 실행하기 위해 만들어진 가장 작은 단위의 프로그램
	기능의 최소단위
	프로그램이란?
		이러한 함수들이 모여서 원하는 목적을 이루도록 구성하는 것.
	참고
		1.함수는 누군가 호출해야만 실행됨-함수 스스로 실행되는 경우는 없다.
		2.함수는 실행이 완료되면 자신을 호출한 곳으로 실행순서를 넘긴다.
함수만드는 법
	형식
		접근지정자 속성 반환값타입 함수이름(매개변수리스트...){
				함수내용
			}
	속성
		final속성, static속성, abstract속성등 등등
	접근지정자
		해당 개체에 접근할 수 있는 권한을 지정해 놓은 것-클래스 부분에서 설명
----
	함수의 이름
		개발자(함수를제작하는 사람)가 지정하는 사용자 정의어
	매개변수리스트
		변수 선언 형태로 만드는 것, 갯수와는 상관이 없음
		함수가 원하는 작업을 하기 위해서 반드시 필요한 데이터가 있을 수 있을 것.
		그러한 데이터를 기억할 준비를 하는것을 매개변수라 한다.
	반환값 타입
		함수는 한 가지 목적을 달성하기 위한 가장 작은 단위의 프로그램이다.
		함수를 실행 한다는 말은 그 목적을 달성하겠다는 의미
		이때 그 달성된 목적에 따라 결과가 존재할 수 있다.
	반환값 타입이란?
		함수가 어떤 작업을 실행한 결과를 알려주는 것.
		이 결과는 경우에 따라서 달라진다.
		결과물이 존재하는 경우와 존재하지 않는 경우가 있음
		존재하는경우 - 그 결과에 대한 타입을 적어준다.
		존재않는경우 - 반드시 void를 적어준다.
		참고
			함수는 가장 작은 한가지 목적을 위해 만들어지는 가장 작은 단위의 프로그램
			따라서 반환값은 한개이거나 없을 수 있음. 반환값이 2개이상인 함수는 자바에서는 절대 없음
		결론
			함수는 4가지의 형태를 벗어날 수 없다.
			1.void abc(){}
			2.int abc(){}
			3.void abc(int no){}
			4.int abc((int no){}
----
	 return 명령
	 	함수 안에서 사용할 수 있는 명령
	 	의미
	 		1. 함수 실행을 종료하세요
	 		2. 결과가 있으면 결과를 내보내고 함수를 종료하세요
	 	형식
	 		1.return; - 1번의 의미
	 		2.return 데이터; - 2번의 의미
	 	참고
	 		반환값이 없는 void의 경우는 반드시 return; 형식만 사용할 수 있다.
	 		반환값이 있는 void가 아닌 경우는 반드시 return 데이터; 형식만 사용
	 		반환값이 없는 void의 경우는 return을 생략할 수 있다.
----
함수의 사용방법
	함수는 반드시 호출되어야 사용할 수 있다.
	따라서 함수를 사용한다는 것은 그 함수를 호출한다는 의미가 된다.
	형식
		함수이름(데이터, ...);
		
		여기서 데이터란?
			함수는 그 함수가 실해되기 위해 필요한 데이터를 받을 준비를 하고 있다.(매개변수)
			따라서 그 함수에 일을 시키기 위해서는 필요한 데이터를 반드시 입력해줘야 한다.
		결론적으로 데이터(파라미터, Parameter)란?
			함수가 준비하고있는 매개변수 리스트에 기억시킬 데이터를 제공하는것.
			데이터는 그 함수가 준비한 매개변수의 갯수와 반드시 일치해야 하고,(넘쳐도x 모자라도x)
			그 형태 역시 일치해야 한다.
----
반환값 사용방법
	함수의 실행이 종료되면 반환값을 쓸 수 있다.
	이 반환값은 함수 호출 부분에 그대로 들어온다.
	따라서 함수 호출 부분에 예상되는 반환값을 기록해 보고
	문법적으로 이상이 없으면 그것이 반환값의 사용이 된다.
----
객체지향언어(Object Oriented Programming:OOP)
	클래스를 이용하여 프로그램을 만들어나가는 언어
클래스
	하나의 목절을 달성하기 위해 필요한 기능들을 모아둔 프로그램의 기본단위
	예]
		문자열을 관리해야겠다.
			-> String클래스
		네트워크를 처리해야겠다.
			-> Soket클래스
	클래스의 구성요소는
		1.변수(Field)	:필요한 데이터를 보관하고 있어야한다.
		2.함수(Method)	:뭔가를 해결하기 위한 기능이 있어야한다.
		위 두개를 합쳐서 멤버(Member)라고 부른다.
클래스를 만드는 방법
	형식]
		접근지정자 [속성] class 클래스이름{
			변수1선언가능;
			변수2선언가능;
			함수1선언가능;
			함수2선언가능;
		}
**클래스는 설계도에 불과합니다.**
	즉, 클래스만 가지고있다 해서 이것이 실행되는 것은 아니고
	반드시 클래스가 실행 가능한 상태로 만들어져야만 실행된다.-> 메모리에 올려진 상태임
	Object=Reference+Instance
	(객체)	(변수)	(인스턴스)
결론
	객체지향언어는 클래스를 기반으로 해서 만들어진 Object에 의해 만들어지는 프로그램
----
객체를 만드는 방법
	객체는 JVM이 만들어준다.
	개발자는 필요한 부품을 만들어달라고 명령만 주면 된다.
	형식]
		클래스이름 변수;
		변수 = new 클래스이름();
	예]
		Test라는 클래스가 있다면.
		Test t;
			t는 레퍼런스(변수)가 된다.
			이 변수의 Heap Type은 Test
		t = new Test();
			:new명령을 통해서 클래스가 Object가 된다.
			컴퓨터가 물건을 만든다는 개념은 메모리에 클래스가 만들어진다는 개념과 같다.
		따라서
			Heap에 만들어진 클래스를 인스턴스라 부르고, 만들어진 Instance의 주소를 기억할 변수를 Reference라 부른다.
			이 두가지를 통칭하여 Object라고 부른다.
	예]
		class Test {
			int a;
			int b;
			void abc(){}
			void xyz(){}
		}
		Test t;
		t = new Test();
----
객체를 사용하는 방법
	객체를 사용한다는 개념은 그 목적을 달성하기 위해 필요한 --데이터를 기억하던지..
															ㄴ기능(함수)을 이용하던지..
	형식]
		주소.변수;
		주소.함수(데이터);
		여기서 주소는 *변수*(알파벳 등)
	예]
		Test 클래스의 a 변수에 10을 기억시키겠다.
		Test t;
		t = new Test();
		//변수가져와서 10 할당시키기
		t.a = 10;
		//함수실행
		t.abc();
	참고***
		클래스 하나당 오브젝트는 여러개 만들어도 상관이 없다.
		즉, 설계도는 한 장만 있어도 되는데 설계도 한 장으로 물건을 여러개 만들 수 있다.
		주소를 이용해서 사용하게 되므로
		예]
			Test t1 = new Test()
			Test t2 = new Test()
			
			toPrint()가 멤버변수a의 내용을 출력하는 기능이라고 가정 할 경우
			t1.a = 10;
			t2.a = 1000;
			
			t1.toPrint(); -> 10출력
			t2.toPrint(); -> 1000출력
		
		따라서 각각의 오브젝트는 별개로 독립되어 실행될 수 있다.
	참]
		지역변수
			해당 지역에서 만 사용할 수 있는 지역변수-그 문장이 실행되는 순간 변수가 만들어지고, 그 블럭을 벗어나면 그 변수는 사라진다.
		전역변수
			모든 지역에서 사용할 수 있는 변수
			클래스 안에서 만들어진 변수는
			new 시키는 순간 Heap영역에 만들어지기 때문이다.
			Heap영역의 특성에 따라서 계속 사용할 수 있다.
			탄생시점은 new 시키는 순간.
			소멸시점은 프로그램이 종료되는 순간.
객체의 배열
	하나의 클래스를 가지고 여러개의 오브젝트를 만들 수 있으므로..
	이 때 만들어진 오브텍트들을 배열로 만들어서 관리할 수 있다.
만드는 방법
	Test[] t;
	==> Test 클래스를 배열로 관리할 주소 변수를 만듬
	t = new Test[갯수];
	==> 관리할 갯수를 정해서 배열을 만듬
		아직 실질적은 오브젝트는 만들어 두지 못한 상태..
	예]
	class Test{
		int a
	}
	
	Test[] t = new Test[5];
	==> Test타입의 객체를 관리할 공간만 확보된 상태.
		따라서 
	
	t[0].a ==> 라고 접근하여 a변수에 기억된 숫자를 꺼내오지 못함
	
	따라서 
	for(int i = 0 ; i < 5 ; i++){
		t[i] = new Test();
	}
	
	이 작업을 해줘야 
	t[0].a ==> 라고 접근하여 a변수에 기억된 숫자를 꺼내올 수 있음

사용방법
	배열변수[위치값].변수이름 = ?;
	베열변수[위치값].함수이름();
	배열변수[위치값] 안에있는 주소는 오브젝트 참조 주소이기때문에...
	" . " 을 이용해서 접근해야 한다.
	=> 소속을 밝혀줘야 하는거라고 보면 된다.
함수의 오버로딩(Overloading:함수의 중첩)
	함수의 이름을 중첩해서 만든다는 의미에서 함수의 중첩이다.
	원칙적으로 한 클래스 안에서 함수의 이름은 모두 달라야 한다.
	같은 이름의 함수가 존재하면 오류가 발생한다.
	이러다 보니 가독성에 있어서 문제가 발생한다.
	
	즉, 가독성이란?
	함수의 이름만 봐도 그 함수가 어떤 기능을 가지고 있는 함수인지 알아야 하는데
	함수의 이름을 보두 다르게 만들다보면
	가독성에 있어서 문제가 발생할 여지가 많아진다.
	
	이런문제를 해결하기 위해서 도입된 문법이 "함수의 오버로딩"이다.
	
	오버로딩이란?
	같은 클래스안에 같은 이름의 함수를 만들 수 있다.
	단, 다음조건은 반드시 지켜져야 한다.
	0.해당 클래스에 오버로딩하여는 함수가 있어야 한다.
	1.함수의 이름이 같아야 한다.
	2.매개변수의 갯수, 순서, 형태 중 하나 이상이 달라야 한다.
	3.반환값과는 상관없다.
	예}
		void abc(){}
		void abc(int a){}				//가능
		
		void xyz(int a){}				//가능
		void xyz(float a){}				//가능
		
		void lmn(int a, float b){}		//가능
		void lmn(float b, int a){}		//가능
		
		int efg(){}
		void efg(){}  					// (X) 이 경우는 불가능하다. 이유는 반환값은 상관이 없기 때문이다.
		
		void hij(int a, int b){}
		void hij(int b, int a){}  		// (X) 이 경우는 불가능하다. 입력되는 타입이 동일하므로 같은 형태로 취급하기 때문이다.
결론]
	함수를 호출할 때 정확한 함수를 선택할 수 있도록 해야한다.
	원래의 함수의 오버로딩 규칙
사용법]
	다른 사람이 만든 클래스에도 오버로딩이 구현된 함수를 볼 수 있다.
	이들 함수를 사용하는 방법
	원하는 기능을 하는 함수가 요구하는 데이터를
	형태와 순서에 맞춰서 정확하게 입력해 주면 된다.





































