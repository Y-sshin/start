#day08

배열의 복사
	종류
		1. 얕은 복사
			==>주소만 복사
			특징 데이터는 공유하기 때문에 한 곳에서 데이터의 내용을 수정하면 다른 한 곳에서도 수정 되어진 내용을 쓰게 된다.\
			방법 
				int[] a = new int [5];
				.....
				int b; 		//이 변수는 배열의 변수를 기억..b 안에는 데이터기억x, 그래서 오직 같은 heap타입의 int 배열의 주소만 기억할 수 있음 
				b=a;		//얕은 복사 방법이 됨 그 결과 a 에서 만든 배열을 공유하게 된다.
			참고
				얕은 복사는 지역변수는  그 지역에서만 사용할 수 있으므로 다른 지역에서 heap영역에 데이터를 사용할 목적으로 많이 사용되는 방법임
		2. 깊은 복사
			==>데이터를 복사하는 방법
			특징 
				데이터가 복사 되었다는 것은 heap영역에 다른 인스턴스(new명령으로 생겨난 결과물)가 만들어졌다는 말이므로 변수가 기억하는 주소가 달라지게 되므로
				복사된 데이터는 독립적으로 사용된다.
			방법
				명령을 사용하여 처리하면 된다.
				System.arraycopy(#1, #2, #3, #4, #5);
					#1 - 원본 배열의 주소
					#2 - 원본 배열의 복사를 시작할 위치
					#3 - 복사받을 배열의 주소
					#4 - 복사받을 배열의 시작위치
					#5 - 복사받을 데이터의 갯수
----
배열의 단점
	한번 배열의 크기를 정하면 크기조절이 불가능
		예] 10개짜리 배열을 만들어 사용하다가 10개를 추가하는 경우 20개짜리를 새로 만들고 10개짜리에서 또 백업까지 해주어야 함
			int[] no1 = new int[10];
			...
			int[] no2 = new int[20];
			System.arraycopy(no1,0,no2,0,10;
			no2[11] = 추가데이터;
			no2[12] = 추가데이터;
	같은 형태의 데이터만 관리할 수 있다.
		주소는 Heap타입에 의해서 결정이 되고, 타입이 다르면 사용할 수 없다.
		예]
			int[] a = new int[10];
			float[] b;
			b=a; //타입이 서로 달라서 이 경우에는 대입을 할 수 없다.
----
String 배열
	String 역시 참조형 타입이다.
	String str = "Hong";
	str에는 데이터 자체의 주소가 기록이 됨
	String str = new String("Hong"); 라고 변수를 만들면 인스턴스의 주소를 기억하고
	인스턴스가 데이터의 주소를 기억한다
----
	String 배열만들기
		String[] str; // 배열변수 선언, 데이터를 사용할 준비
		str = new String[5];//데이터가 초기화가 안되어 있는 상태, 아직 각 인덱스가 비어있는 상태(데이터가 결정이 안되어있는 상태)
		str[0] = "Hong";
		str[1] = "dooly"; //이처럼 데이터 공간까지 만들어줘야 한다.
		
		String 배열도 초기화가 가능
		String[] names = {"둘리","제니","리사","로제","지수"};
----
	참고]
		문자열도 필요에 따라서 char[]형태로 변환하여 사용할 수 있다.
	방법]
		toCharArray();
	예]
		String name = "jenie";
		char[] ch = name.toCharArray(name); //문자 배열로 반환
		ch[0] ->  j
		ch[0] ->  e
		ch[0] ->  n
		...
	참고]
		String 클래스에서 자주 사용되는 함수
			1.charAt(위치값)			 			//문자열 해당 위치의 문자를 알려준다
			2.length()					 			//문자열의 길이를 알려준다.
			3.substring()				 			//문자열 중에서 원하는 문자열만 따로 뽑아서 반환
				형식1]
					subtring(시작위치);		    	//시작위치에서부터 마지막까지 모두 추출
				형식2]
					subtring(시작위치, 종료위치);	//시작위치부터 종료위치 이전 문자까지 반환
				주의
					시작위치는 0부터 카운드해서 지정한다.
					종료위치는 1부터 카운트해서 지정한다.
					(1보다 큰 수를 써야한다는 말)
			4.eqals()								//문자열의 데이터 자체가 같은지 비교하여 논리값으로 반환해주는 함수
----
2차원배열
	1차원 배열을 관리하는 배열 
	배열안에 다시 배열이 들어있는 형대
	(정확히는 배열 안에 1차원 배열의 주소)
	
	만드는 법
		1.배열 주소를 기억할 변수를 만든다.
		Heap영역의 데이터는 주소를 알아야 사용이 가능하기 때문이다.
	방법
		1.데이터타입[][] 변수이름; //3개면 3차원 배열, 더 중첩가능
		예 ]
			int[][] num; //정수를 기억하는 배열들을 관리하는 배열의 선언
			num = new int[5];(X)
		2. 1차원 배열을 몇개를 관리할 지를 결정하고 1차원 배열의 주소를 기억할 메모리를 만든다.
		예 ]
			new 데이터타입[갯수][]; //여기서 갯수는 1차원 배열의 갯수를 지정
			num = new int[5][];(O)
		3.실제 정수를 관리하는 1차원 배열의 길이를 결정하고 1차원 배열의 주소를 기억할 메모리를 만든다.
		예 ]
			new 데이터타입[갯수];
			num[0] = new int[3];
		4. 2차원 배열도 사각형 형태의 배열을 만들 수 있다.
		형식]
			데이터타입[][] 변수 = new 데이터타입[행수][열수];
		예 ]
			int[][] num = new int[5][3];
			정수3개를 관리하는 배열이 5개이고 그 배열을 관리한다.
		5. 2차원 배열고 초기화가 가능하다.
		방법 ]
			int[] num = {데이터1,2,3,4,5}; //데이터 갯수만큼 만들어지고 입력된 데이터로 초기화 됨
			int[][] num1 = {{1,2},{3,4,5},{6,7,8,9},{101,20}};  // 여기서도 배열의 갯수를 지정할 수는 없다.








































































